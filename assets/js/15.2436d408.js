(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{426:function(t,v,e){"use strict";e.r(v);var _=e(2),s=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("blockquote",[v("p",[t._v("javascript 是单线程，同一时间只能执行一件事情")])]),t._v(" "),v("ul",[v("li",[t._v("宏任务\n"),v("ul",[v("li",[t._v("script（整体代码）、setTimeout、setInterval、setImmediate、I/O、UI rendering")])])]),t._v(" "),v("li",[t._v("微任务\n"),v("ul",[v("li",[t._v("promise、Object.observe、MutationObserver")]),t._v(" "),v("li",[t._v("注意：new promise不是微任务，.then,.catch才是异步操作才是微任务")])])]),t._v(" "),v("li",[t._v("优先任务级（微任务大于宏任务）\n"),v("ul",[v("li",[t._v("process.nextTick > promise.then > setTimeout > setImmediate\n"),v("img",{attrs:{src:"/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.png",alt:""}})])])])]),t._v(" "),v("blockquote",[v("p",[t._v("微任务永远跟在"),v("strong",[t._v("当前")]),t._v("宏任务后面")]),t._v(" "),v("p",[t._v("一个宏任务和它下方的所有微任务合在一起统称"),v("strong",[t._v("事件循环")])]),t._v(" "),v("p",[t._v("每一个微任务都有一个微任务队列")]),t._v(" "),v("p",[t._v("执行顺序:同步任务(主线程任务) > 异步任务(微任务 > 宏任务) > 下一次循环")])]),t._v(" "),v("p",[t._v("事件循环机制，大体上由三个部分组成"),v("strong",[t._v("调用栈")]),t._v("（call stack）"),v("strong",[t._v("消息队列")]),t._v("（Message Stack）"),v("strong",[t._v("微任务队列")]),t._v("（Microtask Stack）")]),t._v(" "),v("ul",[v("li",[t._v("调用栈：执行")]),t._v(" "),v("li",[t._v("消息队列：存放宏任务")]),t._v(" "),v("li",[t._v("微任务队列：存放微任务")])]),t._v(" "),v("p",[t._v("流程：自上而下调用--遇到函数调用会把函数压入调用栈当中（被压入的函数叫做帧）--函数调用完返回后会从调用栈当中弹出--遇到宏任务将其加入到消息队列当中--遇到微任务将其加入微任务队列当中--当调用栈为空时，将微任务队列当中内容压入调用栈--再次为空，将消息队列内容压到调用栈当中--一波接一波。。。")])])}),[],!1,null,null,null);v.default=s.exports}}]);