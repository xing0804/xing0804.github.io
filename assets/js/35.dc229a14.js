(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{442:function(t,e,a){"use strict";a.r(e);var s=a(2),v=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"vite相较于webpck的优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vite相较于webpck的优势"}},[t._v("#")]),t._v(" Vite相较于webpck的优势")]),t._v(" "),e("blockquote",[e("p",[t._v("官网：[https://cn.vitejs.dev/guide/why.html]")])]),t._v(" "),e("p",[e("strong",[t._v("引言")]),t._v("：当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR，热更新），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。")]),t._v(" "),e("h3",{attrs:{id:"webpack为什么这么慢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack为什么这么慢"}},[t._v("#")]),t._v(" webpack为什么这么慢")]),t._v(" "),e("p",[t._v("因为webpack支持"),e("strong",[t._v("多种模块化")])]),t._v(" "),e("p",[t._v("它一开始就必须要统一模块化代码，所以意味着它需要将所有的依赖全部读一遍")]),t._v(" "),e("p",[t._v("webpack考虑更多的兼容性 ，考虑到服务端开发，所以Vite不会取代webpack也不会干翻，Vite是基于"),e("strong",[t._v("ES modules")]),t._v("的，只是侧重点不一样，webpack关注"),e("strong",[t._v("兼容性")]),t._v("，Vite关注浏览器端开发体验")])])}),[],!1,null,null,null);e.default=v.exports}}]);