(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{434:function(t,e,a){"use strict";a.r(e);var c=a(2),v=Object(c.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"computed和watch区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch区别"}},[t._v("#")]),t._v(" computed和watch区别")]),t._v(" "),e("h2",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),e("h3",{attrs:{id:"computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[t._v("#")]),t._v(" computed")]),t._v(" "),e("blockquote",[e("p",[t._v("计算属性")])]),t._v(" "),e("p",[t._v("从组件数据中产生新的数据")]),t._v(" "),e("p",[t._v("当被绑定的响应式数据发生改变时，computed也会触发")]),t._v(" "),e("p",[t._v("使用方法：一般设置一个方法，这个方法返回计算之后的结果")]),t._v(" "),e("p",[t._v("computed默认只有getter，但是如果需要时computed也可以使用对象进行配置使用，该配置对象内有两个方法，get和set")]),t._v(" "),e("ul",[e("li",[t._v("get()，也就是上述默认设置的方法，返回计算后的结果")]),t._v(" "),e("li",[t._v("set(newVal)，当你对该计算属性进行设置赋值的时候触发，newVal是被赋值的值")])]),t._v(" "),e("h3",{attrs:{id:"watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[t._v("#")]),t._v(" watch")]),t._v(" "),e("blockquote",[e("p",[t._v("监听器")])]),t._v(" "),e("p",[t._v("监听组件内一个响应式数据的变化，并执行副作用")]),t._v(" "),e("p",[t._v("使用方法：一般是传递一个方法，这个方法就是需要执行的副作用，watch没有返回值，但是可以执行一些异步方法等复杂性逻辑；")]),t._v(" "),e("p",[t._v("watch还可以是一个对象，对象内除了handler函数（也就是上述执行操作的函数）之外，还有deep，immediate等属性。")]),t._v(" "),e("p",[t._v("当我们需要对一个对象进行深度监听的时候，可以设置deep:true，但是这样会对该对象内所有属性进行监听，优化：如果需要监听一个对象内的某个属性的变化，还可以使用.点操作符字符串的形式来进行监听（这类方法还可以用来监听路由的变化，包括路由的传参query以及params）")]),t._v(" "),e("h2",{attrs:{id:"使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),e("h3",{attrs:{id:"computed-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-2"}},[t._v("#")]),t._v(" computed")]),t._v(" "),e("p",[t._v("计算属性设计的初衷时用于简单运算的，为了简化模板中的复杂逻辑，方便维护模板")]),t._v(" "),e("h3",{attrs:{id:"watch-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch-2"}},[t._v("#")]),t._v(" watch")]),t._v(" "),e("p",[t._v("计算属性在大多数使用场景更合适，但是，当需要在数据变化时执行异步或者开销较大的操作时，使用watch还是很有必要的。")]),t._v(" "),e("p",[t._v("二者都可以用来"),e("strong",[t._v("响应数据的变化")]),t._v("，但是个人观点：在能用计算属性就"),e("strong",[t._v("首选计算属性")]),t._v("，当我们需要在数据变化后执行一些"),e("strong",[t._v("异步或者复杂操作")]),t._v("的时候可以选择watch")]),t._v(" "),e("h2",{attrs:{id:"vue3中的变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3中的变化"}},[t._v("#")]),t._v(" vue3中的变化")]),t._v(" "),e("p",[t._v("在vue3中watch不允许在使用点操作符字符串形式来进行监听了，vue3中使用watch、watchEffect来作为监听器。")]),t._v(" "),e("h3",{attrs:{id:"watch和watcheffect"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch和watcheffect"}},[t._v("#")]),t._v(" watch和watchEffect")]),t._v(" "),e("blockquote",[e("p",[t._v("官网地址:https://cn.vuejs.org/guide/essentials/watchers.html")])]),t._v(" "),e("p",[t._v("二者都是监听器,都可以用来监听响应式数据的变化,我们在源码中也可以看到,二者都调用了同一个方法doWatch();")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("首先定义上官网是这么解释的:"),e("code",[t._v("watchEffect")]),t._v(":立即执行一个函数,然后被动地追踪它的以来,并且当依赖改变时重新执行该函数;"),e("code",[t._v("watch")]),t._v(":侦测一个或多个响应式数据源并在数据变化时调用一个回调函数.")])]),t._v(" "),e("li",[e("p",[t._v("可以说"),e("code",[t._v("watchEffect")]),t._v("是一种特殊的"),e("code",[t._v("watch")]),t._v(","),e("code",[t._v("watchEffect")]),t._v("传入的函数既是依赖收集的数据源,也是回调函数,而"),e("code",[t._v("watch")]),t._v("相对而言就比较底层一点,可以接收多种数据源,包括收集依赖的getter函数,因此它可以完全实现watchEffect的功能,同时因为要指定依赖收集的getter函数,依赖可以控制更加精准,而且还可以获取数据改变前后的值(watchEffect获取的都是改变后的值,这个是watch相对于watchEffect最大的区别)")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("watchEffect")]),t._v("在使用时,传入的函数会立即执行一次,而"),e("code",[t._v("watch")]),t._v("默认不会执行回调函数,如果需要,可以传入配置项{'immediate: true'}")])]),t._v(" "),e("li",[e("p",[t._v("从实现上来讲,"),e("code",[t._v("watchEffect(fn)")]),t._v("相当于"),e("code",[t._v("watch(fn, fn, {immediate: true})")])])])]),t._v(" "),e("p",[e("code",[t._v("watchEffect")]),t._v("还有两个其他写法\n"),e("code",[t._v("watchPostEffect")]),t._v("和"),e("code",[t._v("watchSyncEffect")]),t._v("相当于"),e("code",[t._v("watchEffect")]),t._v("在配置项内添加{flush: 'post'}和{flush: 'sync'}")]),t._v(" "),e("p",[e("code",[t._v("watchPostEffect")]),t._v(":在回调函数内可以访问被Vue更新之后的组件的DOM;")]),t._v(" "),e("p",[e("code",[t._v("watchSyncEffect")]),t._v(":在Vue进行任何更新之前触发(谨慎使用)")]),t._v(" "),e("h3",{attrs:{id:"computed原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed原理"}},[t._v("#")]),t._v(" computed原理")]),t._v(" "),e("p",[t._v("涉及响应式原理")])])}),[],!1,null,null,null);e.default=v.exports}}]);